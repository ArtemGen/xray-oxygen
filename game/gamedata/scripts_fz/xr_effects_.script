--[[ ----------------------------------------------------------------------------------------------- 
 File       : xr_effects.script
 Description: 'Исполняемые' функции логики
 Copyright  : 2004 © GSC Game World
 Author     : GSC Game World
 Last edit  : 13.01.2013 (Viнt@rь)
--]] -----------------------------------------------------------------------------------------------
--/											Общие функции
--]] -----------------------------------------------------------------------------------------------
--[[
--	Принудительно апдейтит логику у объектов, переданных параметром. Пока работает только с НПС
--]]
function update_npc_logic(actor, object, p)
	for k,v in pairs(p) do
		local npc = get_story_object(v)
		if npc ~= nil then
			xr_motivator.update_logic(npc)

			local planner = npc:motivation_action_manager()
			planner:update()
			planner:update()
			planner:update()

			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
			db.storage[npc:id()].state_mgr:update()
		end
	end
end

function update_obj_logic(actor, object, p)
	for k,v in pairs(p) do
		local obj = get_story_object(v)
		if obj ~= nil then

			local st = db.storage[obj:id()]
			xr_logic.try_switch_to_another_section(obj, st[st.active_scheme], actor)

--			if st.active_scheme == "sr_cutscene" then
--				st[st.active_scheme].cutscene_action
--			end

		end
	end
end

local ui_active_slot = 0

function disable_ui(actor, npc, p)
	if db.actor:is_talking() then
		db.actor:stop_talk()
	end
	level.show_weapon(false)

	if not p or (p and p[1] ~= "true") then
		local slot = db.actor:active_slot()
		if(slot~=0) then
			ui_active_slot = slot
			db.actor:activate_slot(0)
		end
	end

	level.disable_input()
	level.hide_indicators_safe()
	local hud = get_hud()
	hud:HideActorMenu()
	hud:HidePdaMenu()
	disable_actor_nightvision(nil,nil)
	disable_actor_torch(nil,nil)
end

function disable_ui_only(actor, npc)
	if db.actor:is_talking() then
		db.actor:stop_talk()
	end
	level.show_weapon(false)

	if not p or (p and p[1] ~= "true") then
		local slot = db.actor:active_slot()
		if(slot~=0) then
			ui_active_slot = slot
			db.actor:activate_slot(0)
		end
	end

	level.disable_input()
	level.hide_indicators_safe()
	local hud = get_hud()
	hud:HideActorMenu()
	hud:HidePdaMenu()
end

function enable_ui(actor, npc, p)
	--db.actor:restore_weapon()

	if not p or (p and p[1] ~= "true") then
		if ui_active_slot ~= 0 and db.actor:item_in_slot(ui_active_slot) ~= nil then
			db.actor:activate_slot(ui_active_slot)
		end
	end

	ui_active_slot = 0
	level.show_weapon(true)
	level.enable_input()
	level.show_indicators()
	enable_actor_nightvision(nil,nil)
	enable_actor_torch(nil,nil)
end

local cam_effector_playing_object_id = nil

function run_cam_effector(actor, npc, p)
	if p[1] then
		local loop, num = false, (1000 + math.random(100))
		if p[2] and type(p[2]) == "number" and p[2] > 0 then
			num = p[2]
		end
		if p[3] and p[3] == "true" then
			loop = true
		end
		--level.add_pp_effector(p[1] .. ".ppe", num, loop)
		level.add_cam_effector("camera_effects\\" .. p[1] .. ".anm", num, loop, "xr_effects.cam_effector_callback")
		cam_effector_playing_object_id = npc:id()
	end
end

function stop_cam_effector(actor, npc, p)
	if p[1] and type(p[1]) == "number" and p[1] > 0 then
		level.remove_cam_effector(p[1])
	end
end

function run_cam_effector_global(actor, npc, p)
	local num = 1000 + math.random(100)
	if p[2] and type(p[2]) == "number" and p[2] > 0 then
		 num = p[2]
	end
	local fov = device().fov
	if p[3] ~= nil and type(p[3]) == "number" then
		fov = p[3]
	end
	level.add_cam_effector2("camera_effects\\" .. p[1] .. ".anm", num, false, "xr_effects.cam_effector_callback", fov)
	cam_effector_playing_object_id = npc:id()
end

function cam_effector_callback()
	if cam_effector_playing_object_id == nil then
		return
	end
	local st   = db.storage[cam_effector_playing_object_id]
	if st == nil or st.active_scheme == nil then
		return
	end

	if st[st.active_scheme].signals == nil then
		return
	end
	st[st.active_scheme].signals["cameff_end"] = true
end

function run_postprocess(actor, npc, p)
	if (p[1]) then
		if(system_ini():section_exist(p[1])) then
			local num = 2000 + math.random(100)
			if(p[2] and type(p[2]) == "number" and p[2]>0) then
				num = p[2]
			end
			level.add_complex_effector(p[1], num)
		else
			abort("Complex effector section is no set! [%s]", tostring(p[1]))
		end
	end
end

function stop_postprocess(actor, npc, p)
	if(p[1] and type(p[1]) == "number" and p[1]>0) then
		level.remove_complex_effector(p[1])
	end
end

function run_tutorial(actor, npc, p)
	game.start_tutorial(p[1])
end

--[[
function run_tutorial_if_newbie(actor, npc, p)
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial(p[1])
	end
end
]]--

function teleport_actor(actor, npc, p)
	local point = patrol(p[1])
	local dir
	if p[2] ~= nil then
		local look = patrol(p[2])
		dir = -look:point(0):sub(point:point(0)):getH()
		db.actor:set_actor_direction(dir)
	end

	for k,v in pairs(db.no_weap_zones) do
		local zone = db.zone_by_name[k]
		if utils.npc_in_zone(db.actor, zone) then
			db.no_weap_zones[k] = true
		end
	end

	if npc and npc:name() ~= nil then
		--
	end
	db.actor:set_actor_position(point:point(0))
end


local function reset_animation(npc)
	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr == nil then
		return
	end
	local planner = npc:motivation_action_manager()

	state_mgr.animation:set_state(nil, true)
	state_mgr.animation:set_control()
	state_mgr.animstate:set_state(nil, true)
	state_mgr.animstate:set_control()

	state_mgr:set_state("idle", nil, nil, nil, {fast_set = true})

--	planner:update()
--	planner:update()
--	planner:update()

	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()

	npc:set_body_state(move.standing)
	npc:set_mental_state(anim.free)
end


function teleport_npc(actor, npc, p)
	local patrol_point = p[1]
	local patrol_point_index = p[2] or 0
	if patrol_point == nil then
		abort("Wrong parameters in 'teleport_npc' function!!!")
	end
	local position = patrol(patrol_point):point(patrol_point_index)
	reset_animation(npc)

	npc:set_npc_position(position)
end

function teleport_npc_by_story_id(actor, npc, p)
	local story_id = p[1]
	local patrol_point = p[2]
	local patrol_point_index = p[3] or 0
	if story_id == nil or patrol_point == nil then
		abort("Wrong parameters in 'teleport_npc_by_story_id' function!!!")
	end
	local position = patrol(tostring(patrol_point)):point(patrol_point_index)
	local npc_id = get_story_object_id(story_id)
	if npc_id == nil then
		abort("There is no story object with id [%s]", story_id)
	end
	local cl_object = level.object_by_id(npc_id)
	if cl_object then
		reset_animation(cl_object)
		cl_object:set_npc_position(position)
	else
		alife():object(npc_id).position = position
	end
end

function teleport_squad(actor, npc, p)
	local squad_story_id = p[1]
	local patrol_point = p[2]
	local patrol_point_index = p[3] or 0
	if squad_story_id == nil or patrol_point == nil then
		abort("Wrong parameters in 'teleport_squad' function!!!")
	end
	local position = patrol(patrol_point):point(patrol_point_index)
	local squad = get_story_squad(squad_story_id)
	if squad == nil then
		abort("There is no squad with story id [%s]", squad_story_id)
	end
	squad:set_squad_position(position)
end
-----------------------------------------------------------------------------
--[[
local drop_point, drop_object = 0, 0
local function drop_object_item(item)
	drop_object:drop_item_and_teleport(item, drop_point)
end

function drop_actor_inventory(actor, npc, p)
	if p[1] then
		drop_point  = patrol(p[1]):point(0)
		drop_object = actor
		actor:inventory_for_each(drop_object_item)
	end
end


-- FIXME: drop_npc_inventory doesn't work
function drop_npc_inventory(actor, npc, p)
	if p[1] then
		drop_point  = patrol(p[1]):point(0)
		drop_object = npc
		npc:inventory_for_each(drop_object_item)
	end
end

function drop_npc_item(actor, npc, p)
	if p[1] then
		local item = npc:object(p[1])
		if item then
			npc:drop_item(item)
		end
	end
end

function drop_npc_items(actor, npc, p)
	local item = 0
	for i, v in pairs(p) do
		item = npc:object(v)
		if item then
			npc:drop_item(item)
		end
	end
end
]]--

function give_items(actor, npc, p)
	local pos, lv_id, gv_id, npc_id = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	for i, v in pairs(p) do
		alife():create(v, pos, lv_id, gv_id, npc_id)
	end
end

function give_item(actor, npc, p)
	if p[2] ~= nil then
		npc_id = get_story_object_id(p[2])
	else
		npc_id = npc:id()
	end
	npc = alife():object(npc_id)
	local pos, lv_id, gv_id, npc_id = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	alife():create(p[1], pos, lv_id, gv_id, npc_id)
end

function play_particle_on_path(actor, npc, p)
	local name = p[1]
	local path = p[2]
	local point_prob = p[3]
	if name == nil or path == nil then
		return
	end
	if point_prob == nil then
		point_prob = 100
	end

	local path = patrol(path)
	local count = path:count()
	for a = 0,count-1,1 do
		local particle = particles_object(name)
		if math.random(100) <= point_prob then
			particle:play_at_pos(path:point(a))
		end
	end
end
-----------------------------------------------------------------------------
--[[
--	send_tip(news_id:sender:sender_id)
--			news_id - текст сообщения
--			sender  - иконка сендера
--			sender_id - стори айди сендера
--]]
function send_tip(actor, npc, p)
	news_manager.send_tip(actor, p[1], nil, p[2], nil, p[3])
end

--[[
--	Дать сталкеру небольшой пинок. Например чтоб скинуть его с возвышения.
--	параметры: actor, npc, p[direction,bone,power,impulse,reverse=false]
--			direction - если строка, то считается, что это имя пути и в сторону
--						первой точки производится толчек. Если же это число, то оно
--						рассматривается как story_id персонажа от которого должен поступить хит.
--			bone - строка. Имя кости, по которой наносится удар.
--			power - сила удара
--			impulse - импульс
--			reverse (true/false) - изменение направления удара. по умолчанию false
--]]
function hit_npc(actor, npc, p)
	local h = hit()
	local rev = p[6] and p[6] == 'true'
	h.draftsman = npc
	h.type = hit.wound
	if p[1] ~= "self" then
		local hitter = get_story_object(p[1])
		if not hitter then return end
		if rev then
			h.draftsman = hitter
			h.direction = hitter:position():sub(npc:position())
		else
			h.direction = npc:position():sub(hitter:position())
		end
	else
		if rev then
			h.draftsman = nil
			h.direction = npc:position():sub(patrol(p[2]):point(0))
		else
			h.direction = patrol(p[2]):point(0):sub(npc:position())
		end
	end
	h:bone(p[3])
	h.power = p[4]
	h.impulse = p[5]
	news_manager.send_tip(db.actor, "ХИТ = "..tostring(npc:name()), nil, "recent_surge", nil, nil)
	npc:hit(h)
end

--[[
--	Дать обьекту, заданному story_id, хит.
--	параметры: actor, npc, p[sid,bone,power,impulse,hit_src=npc:position()]
--			sid - story_id обьекта, по которому наносится хит.
--			bone - строка. Имя кости, по которой наносится удар.
--			power - сила удара
--			impulse - импульс
--			hit_src - если число, то рассматривается как story_id обьекта, со стороны
--					  которого наносится хит (он же является и инициатором хита), иначе это
--					  точка (waypoint), из которой по объекту наносится хит.
--					  Если не задано, то берется позиция обьекта, из которого была вызвана данная функция.			  
--]]
function hit_obj(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end
	h.draftsman = sid or npc
	h.type = hit.wound
	obj:hit(h)
end

--[[
function hit_obj_chemical(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
--    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end

	h.draftsman = sid or npc
	h.type = hit.chemical_burn
	obj:hit(h)
end

function hit_obj_fire_wound(actor, npc, p)
	local h = hit()
	local obj = get_story_object(p[1])
	local sid = nil

	if not obj then
--    abort("HIT_OBJ [%s]. Target object does not exist", npc:name())
		return
	end

	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]

	if p[5] then
		sid = get_story_object(sid)
		if sid then
			h.direction = vector():sub(sid:position(), obj:position())
		end
		if not sid then
			h.direction = vector():sub(patrol(p[5]):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end

	h.draftsman = sid or npc
	h.type = hit.fire_wound
	obj:hit(h)
end
]]--

--[[
--	Дать сталкеру небольшой пинок после смерти. Аналогично предыдущему, только направление хита теперь
--	вычисляется через убийцу. Поэтому параметра direction нет.
--	параметры: actor, npc, p[bone,power,impulse]
--	FIXME: killer:position() isn't working			  
--]]
function hit_by_killer(actor, npc, p)
	if not npc then return end
	local t = db.storage[npc:id()].death
	if t == nil or t.killer == -1 then return end
	local killer = db.storage[t.killer]
	if killer == nil then return end
	local p1, p2
	p1 = npc:position()
	p2 = killer:position()
	local h = hit()
	h.draftsman = npc
	h.type = hit.wound
	h.direction = utils.vector_copy_by_val(p1):sub(p2)
	h.bone = p[1]
	h.power = p[2]
	h.impulse = p[3]
	npc:hit(h)
end


function hit_npc_from_actor(actor, npc, p)
	local h = hit()
	local sid = nil
	h.draftsman = actor
	h.type = hit.wound

	if p and p[1] then
		sid = get_story_object(p[1])
		if sid then
			h.direction = actor:position():sub(sid:position())
		end
		if not sid then
			h.direction = actor:position():sub(npc:position())
		end
	else
		h.direction = actor:position():sub(npc:position())
		sid = npc
	end

	h:bone("bip01_spine")
	h.power = 0.001
	h.impulse = 0.001
	sid:hit(h)
end

--  Sp  -------------------------
--[[
--	Хитует нпс от нпс, если задан один параметр (стори айди), то нпс с таким стори айди хитнет нпс у которого вызвали эту функцию.
--	если задано 2 стори айди , то нпс с 1-ым стори айди хитнет нпс со 2-ым стори айди.
--]]
function hit_npc_from_npc(actor, npc, p)
	if p == nil then abort("Invalid parameter in function 'hit_npc_from_npc'!!!!") end
	local h = hit()
	local hitted_npc = npc
	h.draftsman = get_story_object(p[1])
	if p[2] ~= nil then
		hitted_npc = get_story_object(p[2])
	end
	h.type = hit.wound
	h.direction = h.draftsman:position():sub(hitted_npc:position())
	h:bone("bip01_spine")
	h.power = 0.03
	h.impulse = 0.03
	hitted_npc:hit(h)
end

function hit_actor(actor, npc, p)
	local h = hit()
	h.direction = vector():set(0,0,0)
	h.draftsman = actor
	h.type = hit.shock
	h:bone("bip01_spine")
	h.power = (p and p[1] and tonumber(p[1])) or 0.001
	h.impulse = 0.001
	actor:hit(h)
end
--  Sp  -------------------------

function restore_health(actor, npc)
	npc.health = 1
end

function make_enemy(actor, npc, p)
	if p == nil then abort("Invalid parameter in function 'hit_npc_from_npc'!!!!") end
	local h = hit()
	local hitted_npc = npc
	h.draftsman = get_story_object(p[1])
	if p[2] ~= nil then
		hitted_npc = get_story_object(p[2])
	end
	h.type = hit.wound
	h.direction = h.draftsman:position():sub(hitted_npc:position())
	h:bone("bip01_spine")
	h.power = 0.03
	h.impulse = 0.03
	hitted_npc:hit(h)
end

function sniper_fire_mode(actor, npc, p)
	if p[1] == "true" then
		npc:sniper_fire_mode(true)
	else
		npc:sniper_fire_mode(false)
	end
end

function kill_npc(actor, npc, p)
	if p and p[1] then
		npc = get_story_object(p[1])
	end
	if npc ~= nil and npc:alive() then
		npc:kill(npc)
	end
end

function remove_npc(actor, npc, p)
	if p and p[1] then
		npc_id = get_story_object_id(p[1])
	end
	if npc_id ~= nil then
		alife():release(alife():object(npc_id), true)
	end
end

--[[
--	Прибавить к указанному счётчику актёра 1
--]]
function inc_counter(actor, npc, p)
	if p and p[1] then
		local inc_value = p[2] or 1
		local new_value = xr_logic.pstor_retrieve(actor, p[1], 0) + inc_value
		if npc and npc:name() then
			--
		end
		xr_logic.pstor_store(actor, p[1], new_value)
	end
end

function dec_counter(actor, npc, p)
	if p and p[1] then
		local dec_value = p[2] or 1
		local new_value = xr_logic.pstor_retrieve(actor, p[1], 0) - dec_value
		if new_value < 0 then
			new_value = 0
		end
		xr_logic.pstor_store(actor, p[1], new_value)
		if npc and npc:name() then
			--
		end
	end
end

function set_counter(actor, npc, p)
	if p and p[1] then
		local count = p[2] or 0
		xr_logic.pstor_store(actor, p[1], count)
	end
end
------------------------------------------------------------------------------------------------------------------------
--[[
--	Постпроцесс и влияние удара в морду
--]]
function actor_punch(npc)
	if db.actor:position():distance_to_sqr(npc:position()) > 4 then
		return
	end

	set_inactivate_input_time(30)
	level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")

	local active_slot = db.actor:active_slot()
	if active_slot ~= 2 and
		 active_slot ~= 3
	then
		return
	end

	local active_item = db.actor:active_item()
	if active_item then
		db.actor:drop_item(active_item)
	end
end

--[[
--	Забывание обиды
--]]
function clearAbuse(npc)
	xr_abuse.clear_abuse(npc)
end

--[[
--	Выключение динамической лампочки (hanging_lamp)
--]]
function turn_off(actor, npc, p)
	local obj
	for k,v in pairs(p) do
		obj = get_story_object(v)

		if not obj then
			abort("TURN_OFF. Target object with story_id [%s] does not exist", v)
			return
		end
		obj:get_hanging_lamp():turn_off()
	end
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

--[[
--	Включение динамической лампочки (hanging_lamp)
--]]
function turn_on(actor, npc, p)
	local obj
	for k,v in pairs(p) do
		obj = get_story_object(v)

		if not obj then
			abort("TURN_ON [%s]. Target object does not exist", npc:name())
			return
		end
		obj:get_hanging_lamp():turn_on()
	end
end

--[[
--	Включение и запуск динамической лампочки (hanging_lamp)
--]]
function turn_on_and_force(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("TURN_ON_AND_FORCE. Target object does not exist")
		return
	end
	if p[2] == nil then p[2] = 55 end
	if p[3] == nil then p[3] = 14000 end
	obj:set_const_force(vector():set(0,1,0), p[2], p[3])
	obj:start_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_on()
end

--[[
--	Выключение динамической лампочки и партиклов (hanging_lamp)
--]]
function turn_off_and_force(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("TURN_OFF [%s]. Target object does not exist", npc:name())
		return
	end
	obj:stop_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_off()
end


function turn_on_object(actor, npc)
	npc:get_hanging_lamp():turn_on()
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

--[[
--	Вызов этой функции отключит обработчик [combat] боя для персонажа.
--	Используется в случаях, когда все необходимые действия, такие как переключение на другую секцию,
--	уже выполнены, и повторно выполнять их во время боя нельзя (а условия секции [combat] проверяются на каждом
--	апдейте, когда персонаж в бою, если, конечно, не отключены вызовом этой функции).
--]]
function disable_combat_handler(actor, npc)
	if db.storage[npc:id()].combat then
		db.storage[npc:id()].combat.enabled = false
	end

	if db.storage[npc:id()].mob_combat then
		db.storage[npc:id()].mob_combat.enabled = false
	end
end

--[[
--	Вызов этой функции отключит обработчик [combat_ignore] перехвата боя для персонажа.
--]]
function disable_combat_ignore_handler(actor, npc)
	if db.storage[npc:id()].combat_ignore then
		db.storage[npc:id()].combat_ignore.enabled = false
	end
end

--]] -----------------------------------------------------------------------------------------------
--/									Функции для работы с вертолётами
--]] -----------------------------------------------------------------------------------------------
--[[
function heli_set_enemy_actor(actor, npc)
	local st = db.storage[npc:id()]
	if not st.combat.enemy_id and actor:alive() then
		st.combat.enemy_id = actor:id()
		heli_snd.play_snd( st, heli_snd.snd_see_enemy, 1 )
	end
end

function heli_set_enemy(actor, npc, p)
	local st  = db.storage[npc:id()]
	local obj = get_story_object( p[1] )
	if not st.combat.enemy_id and obj:alive() then
		st.combat.enemy_id = obj:id()
		heli_snd.play_snd( st, heli_snd.snd_see_enemy, 1 )
	end
end

function heli_clear_enemy(actor, npc)
	db.storage[npc:id()].combat:forget_enemy()
end
]]--

function heli_start_flame(actor, npc)
	bind_heli.heli_start_flame( npc )
end

function heli_die(actor, npc)
	bind_heli.heli_die( npc )
end

--]] -----------------------------------------------------------------------------------------------
--/								Функции для работы с погодными эффектами
--]] -----------------------------------------------------------------------------------------------
--[[
--	Принудительная установка погодных условий
--	=set_weather(<секция погоды>:true) - установка погоды сразу, false - через некоторое время
--]]
function set_weather(actor, npc, p)
	if (p[1]) then
		if (p[2]=="true") then
			level.set_weather(p[1],true)
		else
			level.set_weather(p[1],false)
		end
	end
end
--[[
function update_weather(actor, npc, p)
	if p and p[1] then
		if p[1] == "true" then
			level_weathers.get_weather_manager():select_weather(true)
		elseif p[1] == "false" then
			level_weathers.get_weather_manager():select_weather(false)
		end
	end
end

function start_small_reject(actor, npc)
	level.set_weather_fx("fx_surge_day_3")
	level.add_pp_effector("vibros_p.ppe", 1974, false)
	this.aes_earthshake(npc)
end

function start_full_reject(actor, npc)
	level.set_weather_fx("fx_surge_day_3")
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
	level.add_cam_effector("camera_effects\\earthquake.anm", 1975, true, "")
end

function stop_full_reject(actor, npc)
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
end

function run_weather_pp(actor,npc, p)
	local weather_fx = p[1]
	if weather_fx == nil then
		weather_fx = "fx_surge_day_3"
	end
	level.set_weather_fx(weather_fx)
end
]]--

function game_disconnect(actor, npc)
	local c = get_console()
	c:execute("disconnect")
--	c:execute_deferred("main_menu off")
--	c:execute_deferred("hide")
end

function game_credits(actor, npc)
	db.gameover_credits_started = true
	game.start_tutorial("credits_seq")
end

function game_over(actor, npc)
	if db.gameover_credits_started ~= true then
		return
	end
	local c = get_console()
	c:execute("main_menu on")
end

function after_credits(actor, npc)
	get_console():execute("main_menu on")
end

function before_credits(actor, npc)
	get_console():execute("main_menu off")
end

function on_tutor_gameover_stop()
	local c = get_console()
	c:execute("main_menu on")
end

function on_tutor_gameover_quickload()
	local c = get_console()
	c:execute("load_last_save")
end

--[[
--	Для смены работы
--]]
function get_stalker_for_new_job(actor, npc, p)
	xr_gulag.find_stalker_for_job(npc,p[1])
end
function switch_to_desired_job(actor, npc, p)
	xr_gulag.switch_to_desired_job(npc)
end

--[[
function death_hit(actor, npc, p)
	 local draftsman = get_story_object (p[1])
	 local hitted_obj = (p[2] ~= nil and get_story_object (p[2])) or npc
	 if draftsman == nil or hitted_obj == nil then
		return
	 end
	 local h = hit()
	 h.power = 1000
	 h.direction = hitted_obj:direction()
	 h.draftsman = draftsman
	 h.impulse = 1
	 h.type = hit.wound
	 hitted_obj:hit(h)
end
]]--

--]] -----------------------------------------------------------------------------------------------
--/									Функции для работы с подспауном
--]] -----------------------------------------------------------------------------------------------
--[[
--	p[1] - секция кого спаунить
--	p[2] - имя патрульного пути где спа унить
--]]
function spawn_object(actor, obj, p)
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_object' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_object' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0
	local yaw = p[4] or 0

	local se_obj = alife():create(spawn_sect,ptr:point(index),ptr:level_vertex_id(0),ptr:game_vertex_id(0))
	if IsStalker(nil, se_obj:clsid()) then
		se_obj:o_torso().yaw = yaw * math.pi / 180
	elseif se_obj:clsid() == clsid.script_phys then
		se_obj:set_yaw(yaw * math.pi / 180)
	end
end

--[[
--	p[1] - секция кого спаунить
--	p[2] - имя патрульного пути где спаунить
--]]
function spawn_corpse(actor, obj, p)
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_corpse' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_corpse' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_corpse' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0

	local se_obj = alife():create(spawn_sect,ptr:point(index),ptr:level_vertex_id(0),ptr:game_vertex_id(0))
	se_obj:kill()
end

--[[
--	p[1] - секция кого спаунить
--	p[2] - стори айди обьекта в который спавнить
--]]
function spawn_object_in(actor, obj, p)
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end
	if p[2] == nil then
		abort("Wrong target_name for 'spawn_object_in' function %s. For object %s", tostring(target_name), obj:name())
	end
--	local box = alife():object(target_name)
--	if(box==nil) then

	local target_obj_id = get_story_object_id(p[2])
	if target_obj_id ~= nil then
		box = alife():object(target_obj_id)
		if box == nil then
			abort("There is no such object %s", p[2])
		end
		alife():create(spawn_sect,vector(),0,0,target_obj_id)
	else
		abort("object is nil %s", tostring(p[2]))
	end
end

--[[
--	p[1] - секция кого спаунить
--	p[2] - имя зоны в которой спаунить
--]]
function spawn_npc_in_zone(actor, obj, p)
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end
	local zone_name = p[2]
	if zone_name == nil then
		abort("Wrong zone_name for 'spawn_object' function %s. For object %s", tostring(zone_name), obj:name())
	end
	if db.zone_by_name[zone_name] == nil then
		abort("Zone %s doesnt exist. Function 'spawn_object' for object %s ", tostring(zone_name), obj:name())
	end
	local zone = db.zone_by_name[zone_name]
	local spawned_obj = alife():create(spawn_sect,zone:position(),zone:level_vertex_id(),zone:game_vertex_id())
	spawned_obj.sim_forced_online = true
	spawned_obj.squad = 1 or p[3]
	db.script_ids[spawned_obj.id] = zone_name
end

function destroy_object(actor, obj, p)
	local sobj
	if p == nil then
		sobj = alife():object(obj:id())
	else
		if p[1] == nil or p[2] == nil then
			abort("Wrong parameters in destroy_object function!!!")
		end
		local target_str = nil
		if p[3] ~= nil then
			target_str = p[1].."|"..p[2]..","..p[3]
		else
			target_str = p[1].."|"..p[2]
		end
		local target_position, target_id, target_init = xr_remark.init_target(obj, target_str)
		if target_id == nil then
			--
		end
		sobj = alife():object(target_id)
	end
	if sobj == nil then
		return
	end
	alife():release(sobj, true)
end

function give_actor(actor, npc, p)
	for k,v in pairs(p) do
		alife():create(v,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id(),db.actor:id())
		news_manager.relocate_item(db.actor, "in", v)
	end
end

function activate_weapon_slot(actor, npc, p)
	db.actor:activate_slot(p[1])
end

function anim_obj_forward(actor, npc, p)
	for k,v in pairs(p) do
		if v ~= nil then
			db.anim_obj_by_name[v]:anim_forward()
		end
	end
end
function anim_obj_backward(actor, npc, p)
	if p[1] ~= nil then
		db.anim_obj_by_name[p[1]]:anim_backward()
	end
end
function anim_obj_stop(actor, npc, p)
	if p[1] ~= nil then
		db.anim_obj_by_name[p[1]]:anim_stop()
	end
end

-- Функции для работы с огненными зонами.
--[[
function turn_on_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[ p[1] ]:turn_on()
end

function turn_off_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[ p[1] ]:turn_off()
end
]]--

--]] -----------------------------------------------------------------------------------------------
--/									Функции для отыгрывания звука
--]] -----------------------------------------------------------------------------------------------
function play_sound(actor, obj, p)
	local theme = p[1]
	local faction = p[2]
	local point = sim_board.get_sim_board().smarts_by_names[p[3]]
	if point ~= nil then
		point = point.id
	elseif p[3]~=nil then
		point = p[3]
	end
	if obj and IsStalker(obj) then
		if not obj:alive() then
			abort("Stalker [%s][%s] is dead, but you wants to say something for you: [%s]!", tostring(obj:id()), tostring(obj:name()), p[1])
		end
	end
	xr_sound.set_sound_play(obj:id(), theme, faction, point)
end

function play_sound_by_story(actor, obj, p)
	local story_obj = get_story_object_id(p[1])
	local theme = p[2]
	local faction = p[3]
	local point = sim_board.get_sim_board().smarts_by_names[p[4]]
	if point ~= nil then
		point = point.id
	elseif p[4]~=nil then
		point = p[4]
	end
	xr_sound.set_sound_play(story_obj, theme, faction, point)
end

function stop_sound(actor, npc)
	xr_sound.stop_sounds_by_id(npc:id())
end

function play_sound_looped(actor, obj, p)
	local theme = p[1]
	xr_sound.play_sound_looped(obj:id(), theme)
end

function stop_sound_looped(actor, obj)
	xr_sound.stop_sound_looped(obj:id())
end

function barrel_explode (actor , npc , p)
	local expl_obj = get_story_object (p[1])
	if expl_obj ~= nil then
		expl_obj:explode(0)
	end
end

--]] -----------------------------------------------------------------------------------------------
--/											Alife support
--]] -----------------------------------------------------------------------------------------------
--[[
function start_sim(actor, obj)
	sim_board.get_sim_board():start_sim()
end

function stop_sim(actor, obj)
	sim_board.get_sim_board():stop_sim()
end

function update_faction_brain(actor, obj, p)
	if p[1] == nil then
		abort("Wrong parameters update_faction_brain")
	end
	local board = sim_board.get_sim_board()
	local player = board.players[ p[1] ]
	if player == nil then
		abort("Can't find player %s", tostring(p[1]))
	end
	player:faction_brain_update()
end
]]--

function create_squad(actor, obj, p)
	if obj ~= nil then
		--
	end
	local squad_id = p[1]
	if squad_id == nil then
		abort("Wrong squad identificator [NIL] in create_squad function")
	end
	local smart_name = p[2]
	if smart_name == nil then
		abort("Wrong smart name [NIL] in create_squad function")
	end

	local ltx = sim_board.squad_ltx

	if not ltx:section_exist(squad_id) then
		abort("Wrong squad identificator [%s]. Squad descr doesnt exist.", tostring(squad_id))
	end

	local board = sim_board.get_sim_board()
	local smart = board.smarts_by_names[smart_name]
	if smart == nil then
		abort("Wrong smart_name [%s] for [%s] faction in create_squad function", tostring(smart_name), tostring(player_name))
	end

	local squad = board:create_squad(smart, squad_id)

	board:enter_smart(squad, smart.id)

	for k in squad:squad_members() do
		board:setup_squad_and_group(k.object)
	end

	squad:update()
end

function create_squad_member(actor, obj, p)
	local squad_member_sect = p[1]
	local story_id			= p[2]
	local position			= nil
	local level_vertex_id	= nil
	local game_vertex_id	= nil
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in 'create_squad_member' function")
	end
	local board = sim_board.get_sim_board()
	local squad = get_story_squad(story_id)
	local squad_smart = board.smarts[squad.smart_id].smrt
	if p[3] ~= nil then
		local spawn_point
		if p[3] == "simulation_point" then
			spawn_point = utils.cfg_get_string(sim_board.squad_ltx, squad:section_name(), "spawn_point", obj, false, "")
			if spawn_point == "" or spawn_point == nil then
				spawn_point = xr_logic.parse_condlist(obj, "spawn_point", "spawn_point", squad_smart.spawn_point)
			else
				spawn_point = xr_logic.parse_condlist(obj, "spawn_point", "spawn_point", spawn_point)
			end
			spawn_point = xr_logic.pick_section_from_condlist(db.actor, obj, spawn_point)
		else
			spawn_point = p[3]
		end
		position 		= patrol(spawn_point):point(0)
		level_vertex_id = patrol(spawn_point):level_vertex_id(0)
		game_vertex_id 	= patrol(spawn_point):game_vertex_id(0)
	else
		local commander = alife():object(squad:commander_id())
		position		= commander.position
		level_vertex_id = commander.m_level_vertex_id
		game_vertex_id	= commander.m_game_vertex_id
	end
	local new_member_id = squad:add_squad_member(squad_member_sect, position,  level_vertex_id, game_vertex_id)
	squad:assign_squad_member_to_smart(new_member_id, squad_smart)
	board:setup_squad_and_group(alife():object(new_member_id))
	--squad_smart:refresh()
	squad:update()
end

function remove_squad(actor, obj, p)
	local story_id = p[1]
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in remove_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	local board = sim_board.get_sim_board()
	board:remove_squad(squad)
end

function kill_squad(actor, obj, p)
	local story_id = p[1]
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in kill_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	local squad_npcs = {}
	for k in squad:squad_members() do
		squad_npcs[k.id] = true
	end

	for k,v in pairs(squad_npcs) do
		local cl_obj = db.storage[k] and db.storage[k].object
		if cl_obj == nil then
			alife():object(tonumber(k)):kill()
		else
			cl_obj:kill(cl_obj)
		end
	end
end

function heal_squad(actor, obj, p)
	local story_id = p[1]
	local health_mod = 1
	if p[2] and p[2] ~= nil then
		health_mod = math.ceil(p[2]/100)
	end
	if story_id == nil then
		abort("Wrong squad identificator [NIL] in heal_squad function")
	end
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	for k in squad:squad_members() do
		local cl_obj = db.storage[k.id] and db.storage[k.id].object
		if cl_obj ~= nil then
			cl_obj.health = health_mod
		end
	end
end

--[[
function update_squad(actor, obj, p)
	local squad_id = p[1]
	if squad_id == nil then
		abort("Wrong squad identificator [NIL] in remove_squad function")
	end
	local board = sim_board.get_sim_board()
	local squad = board.squads[squad_id]
	if squad == nil then
		return
	end
	squad:update()
end
]]--

function clear_smart_terrain(actor, obj, p)
	local smart_name = p[1]
	if smart_name == nil then
		abort("Wrong squad identificator [NIL] in clear_smart_terrain function")
	end

	local board = sim_board.get_sim_board()
	local smart = board.smarts_by_names[smart_name]
	local smart_id = smart.id
	for k,v in pairs(board.smarts[smart_id].squads) do
		if p[2] and p[2] == "false" then
			if not get_object_story_id(v.id) then
				board:exit_smart(v, smart_id)
				board:remove_squad(v)
			end
		else
			board:exit_smart(v, smart_id)
			board:remove_squad(v)
		end
	end
end

--[[
function set_actor_faction(actor, obj, p)
	if p[1] == nil then
		abort("Wrong parameters")
	end
	sim_board.get_sim_board():set_actor_community(p[1])
end
]]--

--]] -----------------------------------------------------------------------------------------------
--/											Quest support
--]] -----------------------------------------------------------------------------------------------
function give_task(actor, obj, p)
	if p[1] == nil then
		abort("No parameter in give_task function.")
	end
	task_manager.get_task_manager():give_task(p[1])
end

function set_active_task(actor, npc, p)
	if(p[1]) then
		local t = db.actor:get_task(tostring(p[1]), true)
		if(t) then
			db.actor:set_active_task(t)
		end
	end
end

--[[
--	Функции для работы с отношениями
--]]
function actor_friend(actor, npc)
	npc:force_set_goodwill(1000, actor)
end

function actor_neutral(actor, npc)
	npc:force_set_goodwill(0, actor)
end

function actor_enemy(actor, npc)
	npc:force_set_goodwill(-1000, actor)
end

function set_squad_neutral_to_actor(actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	squad:set_squad_relation("neutral")
end

function set_squad_friend_to_actor(actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	squad:set_squad_relation("friend")
end

--[[
--	Сделать актера врагом к отряду, передается имя отряда
--]]
function set_squad_enemy_to_actor( actor, npc, p)
	local story_id = p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then
		return
	end
	squad:set_squad_relation("enemy")
end

--[[
function set_friends(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = get_story_object(v)
		if npc1 and npc1:alive() then
			npc:set_relation(game_object.friend, npc1)
			npc1:set_relation(game_object.friend, npc)
		end
	end
end

function set_enemies(actor, npc, p)
	local npc1
	for i, v in pairs(p) do
		npc1 = get_story_object(v)
		if npc1 and npc1:alive() then
			npc:set_relation(game_object.enemy, npc1)
			npc1:set_relation(game_object.enemy, npc)
		end
	end
end

function set_gulag_relation_actor(actor, npc, p)
	if(p[1]) and (p[2]) then
		game_relations.set_gulag_relation_actor(p[1], p[2])
	end
end

function set_factions_community(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) and (p[3]~=nil) then
		game_relations.set_factions_community(p[1], p[2], p[3])
	end
end

function set_squad_community_goodwill(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) and (p[3]~=nil) then
		game_relations.set_squad_community_goodwill(p[1], p[2], p[3])
	end
end
]]--

--[[
--	sets NPC relation to actor
--	set_npc_sympathy(number)
--	call only from npc`s logic
--]]
function set_npc_sympathy(actor, npc, p)
	if(p[1]~=nil) then
		game_relations.set_npc_sympathy(npc, p[1])
	end
end

--[[
--	sets SQUAD relation to actor
--	set_squad_goodwill(faction:number)
--]]
function set_squad_goodwill(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) then
		game_relations.set_squad_goodwill(p[1], p[2])
	end
end

function set_squad_goodwill_to_npc(actor, npc, p)
	if(p[1]~=nil) and (p[2]~=nil) then
		game_relations.set_squad_goodwill_to_npc(npc, p[1], p[2])
	end
end

function inc_faction_goodwill_to_actor(actor, npc, p)
	local community = p[1]
	local delta		= p[2]
	if delta and community then
		game_relations.change_factions_community_num(community,actor:id(), tonumber(delta))
	else
		abort("Wrong parameters in function 'inc_faction_goodwill_to_actor'")
	end
end

function dec_faction_goodwill_to_actor(actor, npc, p)
	local community = p[1]
	local delta		= p[2]
	if delta and community then
		game_relations.change_factions_community_num(community,actor:id(), -tonumber(delta))
	else
		abort("Wrong parameters in function 'dec_faction_goodwill_to_actor'")
	end
end


--[[
function add_custom_static(actor, npc, p)
	if p[1] ~= nil and p[2] ~= nil then
		get_hud():AddCustomStatic(p[1], true)
		get_hud():GetCustomStatic(p[1]):wnd():SetTextST(p[2])
	else
		abort("Invalid parameters in function add_custom_static!!!")
	end
end

function remove_custom_static(actor, npc, p)
	if p[1] ~= nil then
		get_hud():RemoveCustomStatic(p[1])
	else
		abort("Invalid parameters in function remove_custom_static!!!")
	end
end
]]--

function kill_actor(actor, npc)
	db.actor:kill(db.actor)
end

--]] -----------------------------------------------------------------------------------------------
--/											Treasures support
--]] -----------------------------------------------------------------------------------------------
function give_treasure (actor, npc, p)
	if p == nil then
		abort("Required parameter is [NIL]")
	end
	for k,v in pairs(p) do
		treasure_manager.get_treasure_manager():give_treasure(v)
	end
end

--[[
function change_tsg(actor, npc, p)
	npc:change_team(p[1], p[2], p[3])
end

function exit_game(actor, npc)
	get_console():execute("quit")
end
]]--

function start_surge(actor, npc, p)
	surge_manager.start_surge(p)
end

function stop_surge(actor, npc, p)
	surge_manager.stop_surge()
end

function set_surge_mess_and_task(actor, npc, p)
	if(p) then
		surge_manager.set_surge_message(p[1])
		if(p[2]) then
			surge_manager.set_surge_task(p[2])
		end
	end
end

--  Sp  -------------------------
function enable_level_changer(actor, npc, p)
	if(p[1]~=nil) then
		local obj = get_story_object(p[1])
		if(obj) then
			if db.storage[obj:id()] and db.storage[obj:id()].s_obj then
				db.storage[obj:id()].s_obj.enabled = true
				db.storage[obj:id()].s_obj.hint = "level_changer_invitation"
			else
				return
			end
			obj:enable_level_changer(true)
			level_tasks.add_lchanger_location()
			obj:set_level_changer_invitation("level_changer_invitation")
		end
	end
end

function disable_level_changer(actor, npc, p)
	if(p[1]~=nil) then
		local obj = get_story_object(p[1])
		if(obj) then
			if not(db.storage[obj:id()] and db.storage[obj:id()].s_obj) then
				return
			end
			obj:enable_level_changer(false)
			level_tasks.del_lchanger_mapspot(tonumber(p[1]))
			db.storage[obj:id()].s_obj.enabled = false
			if(p[2]==nil) then
				obj:set_level_changer_invitation("level_changer_disabled")
				db.storage[obj:id()].s_obj.hint = "level_changer_disabled"
			else
				obj:set_level_changer_invitation(p[2])
				db.storage[obj:id()].s_obj.hint = p[2]
			end
		end
	end
end

function change_actor_community(actor, npc, p)
	if(p[1]~=nil) then
		db.actor:set_character_community(p[1], 0, 0)
	end
end

function set_faction_community_to_actor(actor, npc, p)
-- run_string xr_effects.change_actor_community(nil,nil,{"actor_dolg"})
	if(p[1]~=nil) and (p[2]~=nil) then
		local rel = 0
		if(p[2]=="enemy") then
			rel = -3000
		elseif(p[2]=="friend") then
			rel = 1000
		end
		db.actor:set_community_goodwill(p[1], rel)
	end
end

function disable_collision(actor, npc)
	npc:wounded(true)
end
function enable_collision(actor, npc)
	npc:wounded(false)
end

function disable_actor_collision(actor, npc)
	actor:wounded(true)
end
function enable_actor_collision(actor, npc)
	actor:wounded(false)
end

function relocate_actor_inventory_to_box(actor, npc, p)
	local function transfer_object_item(item)
		if item:section() ~= "wpn_binoc" and item:section() ~= "wpn_knife" and item:section() ~= "device_torch" then
			db.actor:transfer_item(item, inv_box_1)
			news_manager.relocate_item(db.actor, "out", item:section())
		end
	end
	inv_box_1 = get_story_object (p[1])
	actor:inventory_for_each(transfer_object_item)
end
--  Sp  -------------------------

function set_level_faction_community(actor, npc, p)
	if(p[1]~=nil) and (p[2]~= nil) and (p[3]~= nil) then
		local faction = sim_board.get_sim_board().players[p[1]]
		local goodwill = 0
		if(p[3]=="enemy") then
			goodwill = -3000
		elseif(p[3]=="friend") then
			goodwill = 1000
		end
		for k,v in pairs(faction.squads) do
			local squad_level = alife():level_name(game_graph():vertex(alife():object(v:commander_id()).m_game_vertex_id):level_id())
			if(squad_level==p[2]) then
				for kk in v:squad_members() do
					local npc = kk.object
					local tbl = game_relations.temp_goodwill_table
					if(tbl.communities==nil) then
						tbl.communities = {}
					end
					if(tbl.communities[p[1]]==nil) then
						tbl.communities[p[1]] = {}
					end
					tbl.communities[p[1]][npc.id] = goodwill
					if(db.storage[npc.id]~=nil) then
						game_relations.set_level_faction_community(db.storage[npc.id].object)
					end
				end
			end
		end
	end
end

--  Sp  -------------------------
function make_actor_visible_to_npc(actor,npc,p)
	npc:make_object_visible_somewhen(db.actor)
end
--  Sp  -------------------------

function make_actor_visible_to_squad(actor,npc,p)
	local story_id = p and p[1]
	local squad = get_story_squad(story_id)
	if squad == nil then abort("There is no squad with id[%s]", story_id) end
	for k in squad:squad_members() do
		local obj = level.object_by_id(k.id)
		if obj ~= nil then
			obj:make_object_visible_somewhen( db.actor )
		end
	end
end

function stop_sr_cutscene(actor,npc,p)
	local obj = db.storage[npc:id()]
	if(obj.active_scheme~=nil) then
		obj[obj.active_scheme].signals["cam_effector_stop"] = true
	end
end

--  Sp  -------------------------
function reset_dialog_end_signal(actor, npc, p)
	local st = db.storage[npc:id()]
	if(st.active_scheme==nil) then
		return
	end
	if(st[st.active_scheme].signals==nil) then
		return
	end
	st[st.active_scheme].signals["dialog_end"] = nil
end

function add_map_spot(actor, npc, p)
	if(p[1]==nil) then
		abort("Story id for add map spot function is not set")
	else
		local story_id = tonumber(p[1])
		local id = id_by_sid(story_id)
		if(id==nil) then
			local obj = alife():object(p[1])
			id = obj and obj.id
		end
		if(id~=nil) then
			if(p[2]==nil) then
				p[2] = "primary_task_location"
			end
			if(p[3]==nil) then
				p[3] = "default"
			end
			if level.map_has_object_spot(id, p[2]) == 0 then
				level.map_add_object_spot_ser(id, p[2], p[3])
			end
		else
			abort("Wrong story id or name [%s] for map spot function", tostring(story_id))
		end
	end
end

function remove_map_spot(actor, npc, p)
	if(p[1]==nil) then
		abort("Story id for add map spot function is not set")
	else
		local story_id = tonumber(p[1])
		local id = id_by_sid(story_id)
		if(id==nil) then
			local obj = alife():object(p[1])
			id = obj and obj.id
		end
		if(id~=nil) then
			if(p[2]==nil) then
				p[2] = "primary_task_location"
			end
			if level.map_has_object_spot(id, p[2]) ~= 0 then
				level.map_remove_object_spot(id, p[2])
			end
		else
			abort("Wrong story id or name [%s] for map spot function", tostring(story_id))
		end
	end
end
--  Sp  -------------------------
--]] -----------------------------------------------------------------------------------------------
--/											Anomal fields support
--]] -----------------------------------------------------------------------------------------------
function enable_anomaly(actor, npc, p)
	if p[1] == nil then
		abort("Story id for enable_anomaly function is not set")
	end

	local obj = get_story_object(p[1])
	if not obj then
		abort("There is no object with story_id %s for enable_anomaly function", tostring(p[1]))
	end
	obj:enable_anomaly()
end

function disable_anomaly(actor, npc, p)
	if p[1] == nil then
		abort("Story id for disable_anomaly function is not set")
	end

	local obj = get_story_object(p[1])
	if not obj then
		abort("There is no object with story_id %s for disable_anomaly function", tostring(p[1]))
	end
	obj:disable_anomaly()
end

function launch_signal_rocket(actor, obj, p)
	if p==nil then
		abort("Signal rocket name is not set!")
	end
	if db.signal_light[p[1]] then
		db.signal_light[p[1]]:launch()
	else
		abort("No such signal rocket: [%s] on level", tostring(p[1]))
	end
end

--  Sp  -------------------------
function reset_faction_goodwill(actor, obj, p)
	if db.actor and p[1] then
		local board = sim_board.get_sim_board()
		local faction = board.players[ p[1] ]
		if faction then
			db.actor:set_community_goodwill(p[1], 0)
		end
	end
end
--  Sp  -------------------------

function add_cs_text(actor, npc, p)
	if p[1] then
		local hud = get_hud()
		local cs_text = hud:GetCustomStatic("text_on_screen_center")
		if cs_text then
			hud:RemoveCustomStatic("text_on_screen_center")
		end
		hud:AddCustomStatic("text_on_screen_center", true)
		cs_text = hud:GetCustomStatic("text_on_screen_center")
		cs_text:wnd():TextControl():SetText(game.translate_string(p[1]))
	end
end

function del_cs_text(actor, npc, p)
	local hud = get_hud()
	cs_text = hud:GetCustomStatic("text_on_screen_center")
	if cs_text then
		hud:RemoveCustomStatic("text_on_screen_center")
	end
end

function spawn_item_to_npc(actor, npc, p)
	local new_item = p[1]
	if p[1] then
		alife():create(new_item,
		npc:position(),
		npc:level_vertex_id(),
		npc:game_vertex_id(),
		npc:id())
	end
end

function give_money_to_npc(actor, npc, p)
	local money = p[1]
	if p[1] then
		npc:give_money(money)
	end
end

function seize_money_to_npc(actor, npc, p)
	local money = p[1]
	if p[1] then
		npc:give_money(-money)
	end
end

--[[
--	Передача предмета от непися к неписю
--	relocate_item(item_name:story_id_from:story_id_to)
--]]
function relocate_item(actor, npc, p)
	local item = p and p[1]
	local from_obj = p and get_story_object(p[2])
	local to_obj = p and get_story_object(p[3])
	if to_obj ~= nil then
		if from_obj ~= nil and from_obj:object(item) ~= nil then
			from_obj:transfer_item(from_obj:object(item), to_obj)
		else
			alife():create(item,to_obj:position(),to_obj:level_vertex_id(),to_obj:game_vertex_id(),to_obj:id())
		end
	else
		abort("Couldn't relocate item to NULL")
	end
end

--[[
--	Сделать сквады врагами, передаются два сквада
--	set_squads_enemies(squad_name_1:squad_name_2)
--]]
function set_squads_enemies(actor, npc, p)
	if (p[1] == nil or p[2] == nil) then
		abort("Wrong parameters in function set_squad_enemies")
		return
	end

	local squad_1 = get_story_squad(p[1])
	local squad_2 = get_story_squad(p[2])

	if squad_1 == nil then
		return
	end
	if squad_2 == nil then
		return
	end

 	for k in squad_1:squad_members() do
		local npc_obj_1 = db.storage[k.id] and db.storage[k.id].object
		if npc_obj_1 ~= nil then
			for kk in squad_2:squad_members() do
				local npc_obj_2 = db.storage[kk.id] and db.storage[kk.id].object
				if npc_obj_2 ~= nil then
					npc_obj_1:set_relation(game_object.enemy, npc_obj_2)
					npc_obj_2:set_relation(game_object.enemy, npc_obj_1)
				end
			end
		end
	end
end

--[[
--	Функция установки состояния видимости кровососа.
--	Возможный набор параметров --> story_id:visibility_state(можно вызывать откуда угодно) или visibility_state(если вызывается из кастомдаты кровососа)
--	visibility_state:
--					0 - невидимый
--					1 - полувидимый
--					2 - полностью видимый
--]]
function set_bloodsucker_state(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'set_bloodsucker_state'!!!") end
	local state = p[1]
	if p[2] ~= nil then
		state = p[2]
		npc = get_story_object(p[1])
	end
	if npc ~= nil then
		if state == "default" then
			npc:force_visibility_state(-1)
		else
			npc:force_visibility_state(tonumber(state))
		end
	end
end

--[[
--	Функция вставки предмета в определенную точку, сделал для сцены б57
--]]
function drop_object_item_on_point(actor, npc, p)
	local drop_object = db.actor:object(p[1])
	local drop_point  = patrol(p[2]):point(0)
	db.actor:drop_item_and_teleport(drop_object, drop_point)
end

--[[
--	Функция отнятия предмета у игрока
--]]
function remove_item(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'remove_item'!!!") end
	local item = p[1]

	local obj = db.actor:object(item)
	if obj ~= nil then
		alife():release(alife():object(obj:id()), true)
	else
		abort("Actor has no such item!")
	end
	news_manager.relocate_item(db.actor, "out", item)
end

--[[
--	Сюжетное сохранение в важных местах
--]]
function scenario_autosave(actor, npc, p)
	local save_name = p[1]
	if save_name == nil then
		abort("You are trying to use scenario_autosave without save name")
	end

	if IsImportantSave() then
		local save_param = user_name().." - "..game.translate_string(save_name)
		get_console():execute("save "..save_param)
	end
end

--[[
--	Функция ресетит секвенсную звукокую тему у непися. by peacemaker, hein, redstain
--]]
function reset_sound_npc(actor, npc, p)
	local obj_id = npc:id()
	if obj_id and xr_sound.sound_table and xr_sound.sound_table[obj_id] then
		xr_sound.sound_table[obj_id]:reset(obj_id)
	end
end

function clear_box(actor, npc, p)
	if (p and p[1]) == nil then abort("Wrong parameters in function 'clear_box'!!!") end

	local inv_box = get_story_object(p[1])

	if inv_box == nil then
		abort("There is no object with story_id [%s]", tostring(p[1]))
	end

	local items_table = {}

	local function add_items(inv_box, item)
		table.insert(items_table, item)
	end

	inv_box:iterate_inventory_box(add_items, inv_box)

	for k,v in pairs(items_table) do
		alife():release(alife():object(v:id()), true)
	end
end

function activate_weapon(actor, npc, p)
	local object = actor:object(p[1])
	if object == nil then
		--
	end
	if object ~= nil then
		actor:make_item_active(object)
	end
end

function set_game_time(actor, npc, p)
	local real_hours = level.get_time_hours()
	local real_minutes = level.get_time_minutes()
	local hours = tonumber(p[1])
	local minutes = tonumber(p[2])
	if p[2] == nil then
		minutes = 0
	end
	local hours_to_change = hours - real_hours
	if hours_to_change <= 0 then
		hours_to_change = hours_to_change + 24
	end
	local minutes_to_change = minutes - real_minutes
	if minutes_to_change <= 0 then
		minutes_to_change = minutes_to_change + 60
		hours_to_change = hours_to_change - 1
	elseif hours == real_hours then
		hours_to_change = hours_to_change - 24
	end
	level.change_game_time(0,hours_to_change,minutes_to_change)
	level_weathers.get_weather_manager():forced_weather_change()
	surge_manager.get_surge_manager().time_forwarded = true
end

function forward_game_time(actor, npc, p)
	if not p then
		abort("Insufficient or invalid parameters in function 'forward_game_time'!")
	end

	local hours = tonumber(p[1])
	local minutes = tonumber(p[2])

	if p[2] == nil then
		minutes = 0
	end
	level.change_game_time(0,hours,minutes)
	level_weathers.get_weather_manager():forced_weather_change()
	surge_manager.get_surge_manager().time_forwarded = true
end

function stop_tutorial()
	game.stop_tutorial()
end

function pick_artefact_from_anomaly(actor, npc, p)
	local npc
	local az_name = p and p[2]
	local af_name = p and p[3]
	local af_id
	local af_obj
	local anomal_zone = db.anomaly_by_name[az_name]

	if p and p[1] then
--		if p[1] == "actor" then
--			npc = db.actor
--		else
--			npc = get_story_object(p[1])
--		end

		local npc_id = get_story_object_id(p[1])
		if npc_id == nil then
			abort("Couldn't relocate item to NULL in function 'pick_artefact_from_anomaly!'")
		end
		npc = alife():object(npc_id)
		if npc and (not IsStalker(npc) or not npc:alive()) then
			abort("Couldn't relocate item to NULL (dead or not stalker) in function 'pick_artefact_from_anomaly!'")
		end
	end

	if anomal_zone == nil then
		abort("No such anomal zone in function 'pick_artefact_from_anomaly!'")
	end

	if anomal_zone.spawned_count < 1 then
		return
	end

	for k,v in pairs(anomal_zone.artefact_ways_by_id) do
		if alife():object(tonumber(k)) and af_name == alife():object(tonumber(k)):section_name() then
			af_id = tonumber(k)
			af_obj = alife():object(tonumber(k))
			break
		end
		if af_name == nil then
			af_id = tonumber(k)
			af_obj = alife():object(tonumber(k))
			af_name = af_obj:section_name()
			break
		end
	end

	if af_id == nil then
		return
	end

	anomal_zone:on_artefact_take(af_obj)

	alife():release(af_obj, true)
	give_item(db.actor, npc, {af_name, p[1]})
--	alife():create(af_name,
--		npc.position,
--		npc.level_vertex_id,
--		npc.game_vertex_id,
--		npc.id)
end

function anomaly_turn_off(actor, npc, p)
	local anomal_zone = db.anomaly_by_name[p[1]]
	if anomal_zone == nil then
		abort("No such anomal zone in function 'anomaly_turn_off!'")
	end
	anomal_zone:turn_off()
end

function anomaly_turn_on(actor, npc, p)
	local anomal_zone = db.anomaly_by_name[p[1]]
	if anomal_zone == nil then
		abort("No such anomal zone in function 'anomaly_turn_on!'")
	end
	if p[2] then
		anomal_zone:turn_on(true)
	else
		anomal_zone:turn_on(false)
	end
end

function oasis_heal()
	local d_health = 0.005
	local d_power = 0.01
	local d_bleeding = 0.05
	local d_radiation = -0.05
	if(db.actor.health<1) then
		db.actor.health = d_health
	end
	if(db.actor.power<1) then
		db.actor.power = d_power
	end
	if(db.actor.radiation>0) then
		db.actor.radiation = d_radiation
	end
	if(db.actor.bleeding>0) then
		db.actor.bleeding = d_bleeding
	end
	db.actor.satiety = 0.01
end

function pas_b400_play_particle(actor, npc, p)
	db.actor:start_particles("zones\\zone_acidic_idle","bip01_head")
end

function pas_b400_stop_particle(actor, npc, p)
	db.actor:stop_particles("zones\\zone_acidic_idle","bip01_head")
end

function damage_actor_items_on_start(actor, npc)
	local actor = db.actor

	local obj = actor:object("helm_respirator")
	if obj ~= nil then
		obj:set_condition(0.8)
	end

	obj = actor:object("stalker_outfit")
	if obj ~= nil then
		obj:set_condition(0.76)
	end

	obj = actor:object("wpn_pm_actor")
	if obj ~= nil then
		obj:set_condition(0.9)
	end

	obj = actor:object("wpn_ak74u")
	if obj ~= nil then
		obj:set_condition(0.7)
	end
end

function sleep(actor, npc)
	local sleep_zones = {}

	for k,v in pairs(sleep_zones) do
		if utils.npc_in_zone(db.actor, db.zone_by_name[v]) then
			ui_sleep_dialog.sleep()
			give_info("sleep_active")
		end
	end

end

--[[
function set_tip_to_story(actor, npc, p)
	if p == nil or p[2] == nil then
		abort("Not enough parameters in 'set_tip_to_story' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end

	local tip = p[2]

	obj:set_tip_text(tip)
end

function clear_tip_from_story(actor, npc, p)
	if p == nil or p[1] == nil then
		abort("Not enough parameters in 'clear_tip_from_story' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end

	obj:set_tip_text("")
end
]]--

function mech_discount(actor, npc, p)
	if(p[1]) then
		inventory_upgrades.mech_discount(tonumber(p[1]))
	end
end

function polter_actor_ignore(actor, npc, p)
	if p[1] and p[1] == "true" then
		npc:poltergeist_set_actor_ignore(true)
	elseif p[1] and p[1] == "false" then
		npc:poltergeist_set_actor_ignore(false)
	end
end

function burer_force_gravi_attack(actor, npc)
	npc:burer_set_force_gravi_attack(true)
end

function burer_force_anti_aim(actor, npc)
	npc:set_force_anti_aim(true)
end

function show_freeplay_dialog(actor, npc, p)
	if p[1] and p[2] and p[2] == "true" then
		ui_freeplay_dialog.show("message_box_yes_no", p[1])
	elseif p[1] then
		ui_freeplay_dialog.show("message_box_ok", p[1])
	end
end

--[[
--	Только для state_mgr
--]]
local detectors = {"detector_simple", "detector_advanced", "detector_elite", "detector_scientific"}
function get_best_detector(npc)
	for k,v in pairs(detectors) do
		local obj = npc:object(v)
		if obj ~= nil then
			obj:enable_attachable_item(true)
			return
		end
	end
end

function hide_best_detector(npc)
	for k,v in pairs(detectors) do
		local obj = npc:object(v)
		if obj ~= nil then
			obj:enable_attachable_item(false)
			return
		end
	end
end

function set_torch_state(actor, npc, p)
 	if p == nil or p[2] == nil then
		abort("Not enough parameters in 'set_torch_state' function!")
	end

	local obj = get_story_object(p[1])

	if not obj then
		return
	end
	local torch = obj:object("device_torch")
	if torch then
		if p[2] == "on" then
			torch:enable_attachable_item(true)
		elseif p[2] == "off" then
			torch:enable_attachable_item(false)
		end
	end
end


local actor_nightvision = false
local actor_torch		= false

function disable_actor_nightvision(actor, npc)
	local nightvision = db.actor:object("device_torch")
	if nightvision:night_vision_enabled() then
		nightvision:enable_night_vision(false)
		actor_nightvision = true
	end
end

function enable_actor_nightvision(actor, npc)
	local nightvision = db.actor:object("device_torch")
	if not nightvision:night_vision_enabled() and actor_nightvision then
		nightvision:enable_night_vision(true)
		actor_nightvision = false
	end
end

function disable_actor_torch(actor, npc)
	local torch = db.actor:object("device_torch")
	if torch:torch_enabled() then
		torch:enable_torch(false)
		actor_torch = true
	end
end

function enable_actor_torch(actor, npc)
	local torch = db.actor:object("device_torch")
	if not torch:torch_enabled() and actor_torch then
		torch:enable_torch(true)
		actor_torch = false
	end
end

--[[
--	p[1] - секция кого спаунить
--	p[2] - имя патрульного пути где спаунить.
--	p[3] - точка патрульного пути
--	p[4] - поворот по оси Y
--	p[5] - принудительный слот - будет работать даже при disable_ui
--]]
function create_cutscene_actor_with_weapon(actor, npc, p)
	local spawn_sect = p[1]
	if spawn_sect == nil then
		abort("Wrong spawn section for 'spawn_object' function %s. For object %s", tostring(spawn_sect), obj:name())
	end

	local path_name = p[2]
	if path_name == nil then
		abort("Wrong path_name for 'spawn_object' function %s. For object %s", tostring(path_name), obj:name())
	end

	if not level.patrol_path_exists(path_name) then
		abort("Path %s doesnt exist. Function 'spawn_object' for object %s ", tostring(path_name), obj:name())
	end
	local ptr = patrol(path_name)
	local index = p[3] or 0
	local yaw = p[4] or 0

	local npc = alife():create(spawn_sect, ptr:point(index), ptr:level_vertex_id(0), ptr:game_vertex_id(0))
	if IsStalker( nil, npc:clsid()) then
		npc:o_torso().yaw = yaw * math.pi / 180
	else
		npc.angle.y = yaw * math.pi / 180
	end

	local slot_override = p[5] or 0

	local slot
	local active_item

	if slot_override == 0 then
		slot = db.actor:active_slot()
		if(slot~=2 and slot~=3) then
			return
		end
		active_item = db.actor:active_item()
	else
		if db.actor:item_in_slot(slot_override) ~= nil then
			active_item = db.actor:item_in_slot(slot_override)
		else
			if db.actor:item_in_slot(3) ~= nil then
				active_item = db.actor:item_in_slot(3)
			elseif db.actor:item_in_slot(2) ~= nil then
				active_item = db.actor:item_in_slot(2)
			else
				return
			end
		end
	end

	local actor_weapon = alife():object(active_item:id())
	local section_name = actor_weapon:section_name()
	if section_name == "pri_a17_gauss_rifle" then
		section_name = "wpn_gauss"
	end

	if (active_item) then
		local new_weapon = alife():create(section_name,ptr:point(index),ptr:level_vertex_id(0),ptr:game_vertex_id(0),npc.id)
		if section_name ~= "wpn_gauss" then
			new_weapon:clone_addons(actor_weapon)
		end
	end
end

--[[
--	Заставить играть уникальные анимации сна(у кровососа)
--]]
function set_force_sleep_animation(actor, npc, p)
	local num = p[1]
	npc:force_stand_sleep_animation(tonumber(num))
end

--[[
--	Убрать уникальные анимации сна(у кровососа)
--]]
function release_force_sleep_animation(actor, npc)
	npc:release_stand_sleep_animation()
end

--[[
--	Отключение воздействия вражеского нпс на индикатор видимости врага на хаде игрока.
--	Исп. только из логики нпс.
--]]
function set_visual_memory_enabled(actor, npc, p)
	if (p and p[1]) and (tonumber(p[1]) >= 0) and (tonumber(p[1]) <= 1) then
		local boolval = false
		if (tonumber(p[1]) == 1) then
			boolval = true
		end
		npc:set_visual_memory_enabled(boolval)
	end
end

function disable_memory_object(actor, npc)
	local best_enemy = npc:best_enemy()
	if best_enemy then
		npc:enable_memory_object(best_enemy, false)
	end
end

function set_monster_animation(actor, npc, p)
	if not (p and p[1]) then
		abort("Wrong parameters in function 'set_monster_animation'!!!")
	end
	npc:set_override_animation(p[1])
end

function clear_monster_animation(actor, npc)
	npc:clear_override_animation()
end

local actor_position_for_restore
local actor_direction_for_restore

function save_actor_position()
	actor_position_for_restore = get_story_object("actor"):position()
	--actor_direction_for_restore = get_story_object("actor"):direction()
end

function restore_actor_position()
	--db.actor:set_actor_direction(actor_direction_for_restore)
	db.actor:set_actor_position(actor_position_for_restore)
end

function upgrade_hint(actor, npc, p)
	if p then
		inventory_upgrades.cur_hint = p
	end
end

function force_obj(actor, npc, p)
	local obj = get_story_object(p[1])
	if not obj then
		abort("'force_obj' Target object does not exist")
		return
	end
	if p[2] == nil then p[2] = 20 end
	if p[3] == nil then p[3] = 100 end
	obj:set_const_force(vector():set(0,1,0), p[2], p[3])
end

function eat_vodka_script()
	if db.actor:object("vodka_script") ~= nil then
		db.actor:eat(db.actor:object("vodka_script"))
	end
end

--]] -----------------------------------------------------------------------------------------------
--/											Sp: New Functions
--]] -----------------------------------------------------------------------------------------------
--[[---------------------------------------------------------------
--// 				Send Tips Function
--]]---------------------------------------------------------------
--[[
--	Выдача сообщения актору
--	ВЫЗОВ ИЗ ЛОГИКИ!
--	SendTipFL(nText:nHeader:iSender:tOut:tShow:pSnd)
--				p[1] - text		- строка, текст сообщения
--				p[2] - header	- строка, заголовок сообщения
--				p[3] - sender	- строка, иконка сендера
--				p[4] - show		- число,  задержка сообщения на экране
--				p[5] - out		- число,  задержка перед выдачей сообщения
--				p[6] - sound	- строка, имя проиграемого саунда при выдаче сообщения
--]]
function SendTipFromLogic(actor, npc, p)
	if not p[4] then p[4] = 10 end
	SendTip(p[1],p[2],p[5],p[4],p[3],p[6])
end

--[[---------------------------------------------------------------
--// 					Functions
--]]---------------------------------------------------------------
--[[
--	Выставить p[1] игрового времени
--	ВЫЗОВ ИЗ ЛОГИКИ!!!! 
--	TODO TESTING FUNCTION TO BE DELETED
--]]
function ChGameTime(actor, npc, p)
	level.change_game_time(0,p[1],0)
end

--[[
--	Удаление всех денег у ГГ
--]]
function StealActAllMoney()
	db.actor:give_money(-db.actor:money())
end

--[[
--	Изменение погоды
--]]
function SetWeather(actor, npc, p)
    level.set_weather(p[1],true)
    level_weathers.get_weather_manager():select_weather(true)
end

function squad_run_to_cover(actor, npc, p)
	if (p and p[1]) then
		squad_object = get_story_squad(p[1])
		if squad_object then
			squad_commander_id = squad_object:commander_id()
			commander_object = level.object_by_id(squad_commander_id)
			if commander_object then
				state_mgr.set_state(commander_object, "run")
			end
			for squad_member in squad_object:squad_members() do
				local obj = db.storage[squad_member.id] and db.storage[squad_member.id].object
				if(obj) then
					obj:set_fov(1) --портим неписю угол зрения
					obj:set_range(1) --портим неписю дальность зрения
				end
			end
		end
	end
end
function squad_walk_from_cover(actor, npc, p)
	if (p and p[1]) then
		squad_object = get_story_squad(p[1])
		if squad_object then
			squad_commander_id = squad_object:commander_id()
			commander_object = level.object_by_id(squad_commander_id)
			if commander_object then
				state_mgr.set_state(commander_object, "walk")
			end
			for squad_member in squad_object:squad_members() do
				local obj = db.storage[squad_member.id] and db.storage[squad_member.id].object
				if(obj) then
					obj:set_fov(160) --восстанавливаем неписю угол зрения стандартный
					obj:set_range(100) --восстанавливаем неписю дальность зрения стандартную
				end
			end
		end
	end
end

function ockolki_padajte(actor, obj)
	alife():create("pri_a25_enter_door_explosive_grenade", vector():set(-516.667236328125,33.9859046936035,-371.6162109375), 0, db.actor:game_vertex_id())
end

function black_lake_trube(actor, obj)
	alife():create("black_lake_truba_crash_expl_1", vector():set(-516.667236328125,33.9859046936035,-371.6162109375), 0, db.actor:game_vertex_id())
end
------------------------------------------------------------------------------------------